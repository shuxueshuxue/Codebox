## Codebox 后端开发文档（基于 PolyAgent）

### 1. 概览

- **技术栈**：FastAPI + SQLAlchemy + MySQL + PolyAgent（SessionRegistry）
- **API 前缀**：`/api/v1`
- **运行环境**：Python 3.11+，Windows/PowerShell 支持良好
- **Agent 工具规范**：所有“写码/改码”均通过 `cli="qwen-code"`；`agent.run` 仅可在 `@pattern` 内调用；`@pattern` 仅在会话（`session()` 或 `@session_def`）上下文内使用
- **存储策略**：业务数据入库 MySQL；不使用外键，全部由代码控制一致性；布局坐标持久化到 `features.hex_q/hex_r`

### 2. 核心业务概念与落地

- **Agent**：等同“人”，执行具体智能动作；在本系统由 PolyAgent 统一封装，`write_code` 等写码场景统一指定 `cli="qwen-code"`
- **Session**：任务流程（DAG 风格）。通过 `@session_def` 暴露为可触发的“会话任务”，内含可追踪的 `@pattern` 步骤；SessionRegistry 提供 UI/API 监控
- **Feature（功能节点）**：页面六边形格中的一个功能；包含名称/描述/标签/布局坐标 `(hex_q, hex_r)`；与其他 Feature 通过依赖边 `Edge` 关联
- **Edge（依赖边）**：从 A 到 B 的依赖/增强/阻塞关系；上层展示会尽量将有关联的节点靠近；底层以边（而非邻接坐标）为真值
- **Task（任务）**：一次会话（session_id）对一组功能（features）与 agent 的执行配置（可作为批量触发来源）
- **文件树与文件依赖**：为 LLM 决策“是否需要读取/修改某个文件”提供结构化上下文：`feature_details.files_json`（文件角色/读写）与 `feature_details.file_deps_json`（文件级依赖）

### 3. 数据库设计（与 ORM 映射）

通用审计字段（所有表）：`id`（bigint 主键）、`str_id`、`is_deleted`、`create_user_id/create_time`、`update_user_id/update_time`、`data_user_id/data_dept_id`。

- `projects` → ORM: `app/db/models/project.py: Project`
  - `name` 唯一；`workspace_root`、`status`
- `features` → ORM: `app/db/models/feature.py: Feature`
  - 归属 `project_id`；`name` 唯一（项目内）；`category/tags_json`；`hex_q/hex_r` 六边形坐标；`layout_locked`（1=锁定不参与自动布局）
- `edges` → ORM: `app/db/models/edge.py: Edge`
  - `project_id`；`from_feature_id/to_feature_id`；`kind`（requires|enhances|blocks）；`confidence`
- `files` → ORM: `app/db/models/file.py: File`
  - 工作区内文件与目录索引；`path/is_dir/size_bytes/hash_sha256/lang/parent_path/last_scanned_time`
- `feature_details` → ORM: `app/db/models/feature_detail.py: FeatureDetail`
  - `files_json`（[{path,role,rw,notes}]）与 `file_deps_json`（[{src,dst,dep_type,inferred_by,confidence}]）等结构化上下文
- `tasks` → ORM: `app/db/models/task.py: Task`
  - `session_id`（PolyAgent 会话 ID）、`agent_ids_json`、`feature_ids_json`、`params_json`、`status`
- `session_runs` → ORM: `app/db/models/session_run.py: SessionRun`
  - 会话触发记录：`session_id/name/task_id/params_json/status/result_json/records_json/started_at/ended_at`

说明：所有主键 `id` 由代码生成（Snowflake），不依赖数据库自增。

### 4. 目录与文件职责

```
app/
  core/
    config.py           # 读取 .env，集中配置（API_PREFIX、MYSQL_URI、WORKSPACE_ROOT 等）
    deps.py             # FastAPI 依赖：DB 会话 get_db()
  db/
    base.py             # SQLAlchemy Base
    session.py          # SQLAlchemy engine / SessionLocal
    models/
      __init__.py       # ORM 模型聚合导出
      project.py        # Project ORM
      feature.py        # Feature ORM
      edge.py           # Edge ORM
      file.py           # File ORM
      feature_detail.py # FeatureDetail ORM
      task.py           # Task ORM
      session_run.py    # SessionRun ORM
  schemas/
    project.py          # ProjectCreate/ProjectOut
    feature.py          # FeatureCreate/FeatureUpdate/FeatureOut
    edge.py             # EdgeCreate/EdgeOut
    file.py             # FileOut
    feature_detail.py   # FileItem/FileDep/FeatureDetailsPayload
    graph.py            # HexCell/FeatureNode/Edge(Graph)/GraphSnapshot
    task.py             # TaskCreate/TaskOut
  services/
    layout_hex_service.py     # 六边形自动布局（BFS 分层 → 轴坐标），写回 features.hex_q/hex_r
    file_scan_service.py      # 工作区扫描入库、文件哈希、语言识别、静态依赖推断（Python/TS/JS）
    session_bridge_service.py # 桥接 PolyAgent SessionRegistry：列出/触发/运行中；预存 run 记录
  routers/ (全部挂载在 /api/v1)
    projects.py        # 项目 CRUD（目前实现：创建/列表）
    features.py        # 功能 CRUD、写入/更新 feature_details
    edges.py           # 依赖边增查
    files.py           # 扫描工作区、按父目录列出文件、静态依赖推断
    graph.py           # 图谱快照、自动布局、批量布局写入
    sessions.py        # 列会话、运行中、触发、状态、SSE（占位 keep-alive）、停止/取消
    tasks.py           # 任务增查
    agents.py          # Agent 健康检查（qwen-code CLI 可用性）
  sessions/            # 仅在此处定义 @pattern 与 @session_def（顶层定义，便于追踪）
    __init__.py        # 导入并注册所有会话定义
    common_patterns.py # read_file / write_code（写码统一 cli="qwen-code"）
    planning_sessions.py# generate_structure_plan + project_structure_planner（结构化输出）
  utils/
    id_gen.py          # Snowflake 主键生成（generate_id）
  main.py              # 应用入口：创建 app、注册子路由、导入 sessions 完成注册
```

### 5. 配置与环境

- `.env`（示例键）：

  - `APP_NAME=Codebox API`
  - `API_PREFIX=/api/v1`
  - `WORKSPACE_ROOT=F:/Codebox/workspace`
  - `MYSQL_URI=mysql+pymysql://root:***@host:port/codebox`
  - `AUTO_SERVE_SESSION_UI=false`
  - `POLYCLI_CACHE=true`

- 安装依赖：

```bash
pip install -r requirements.txt
```

- 启动服务（推荐）：

```bash
python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

- Windows 多环境注意：确保 `uvicorn` 与 `sqlalchemy` 来自同一 Python 解释器；避免 `ModuleNotFoundError: sqlalchemy`。

### 6. 服务与算法细节

- `layout_hex_service.plan_layout_simple(db, project_id)`

  - 构建入度表，Kahn BFS 分层：入度为 0 的节点为第 0 层，逐层拓展
  - 每层横向按索引排布，映射到六边形轴坐标：`q = col - (row // 2)`, `r = row`
  - 冲突用“向右线性探测”占位；`layout_locked=1` 的节点保持原位不动
  - `apply_layout` 批量写回 `features.hex_q/hex_r`

- 文件扫描与列表（性能优化版）

  - 全局扫描（不再默认前端调用）：`file_scan_service.scan_workspace(db, project_id)`
    - 递归遍历 `WORKSPACE_ROOT`，生成/更新 `files` 索引；按需计算哈希；已启用 upsert 避免唯一键冲突
    - 新增 .env 配置：
      - `SCAN_IGNORE_DIRS=".git,.conda,node_modules,.venv,.polycache,.cache,.mypy_cache,.pytest_cache"`
      - `SCAN_MAX_DEPTH=12`
      - `SCAN_HASH=false`
      - `SCAN_HASH_MAX_BYTES=1048576`
    - 启用响应压缩：`GZipMiddleware(minimum_size=1024)`
  - 层级增量刷新：`file_scan_service.scan_one_level(db, project_id, parent)`
    - 仅刷新某目录第一层（非递归），忽略大目录名，做增量更新
    - 列表接口 `GET /projects/{pid}/files` 在 `refresh=true` 时自动调用，仅刷新当前层

- `file_scan_service.infer_deps(db, project_id, paths=None)`
  - Python：AST 提取 `import`/`from` 模块，并解析为可能的相对路径（`a.b.c → a/b/c.py` 或 `__init__.py`）
  - TS/JS：正则匹配 `import ... from '...'` 及 `require('...')`，仅解析相对路径模块；尝试 `.ts/.tsx/.js/.jsx/.d.ts` 与 `/index.*`
  - 结果样例：

```json
{
  "deps": [{ "src": "app/routes.py", "dst": "app/auth.py", "dep_type": "import", "inferred_by": "static", "confidence": 0.9 }]
}
```

- `session_bridge_service`（方案 A）

  - 直接调用 PolyAgent 的 `SessionRegistry`：`list_sessions()/list_running()/trigger_session()`
  - 触发后在 `session_runs` 预存一条 `status=running` 的记录；结束状态更新接口预留（`update_run_status`）

- `sessions`（基于 PolyAgent）
  - `common_patterns.py`
    - `read_file(agent, path)`：示例读取与总结，统一 `cli="qwen-code"`
    - `write_code(agent, instruction, files_payload)`：写码入口，注入结构化文件上下文
  - `planning_sessions.py`
    - `@pattern generate_structure_plan(...) -> StructurePlan`：架构规划结构化输出
    - `@session_def project_structure_planner(...)`：会话入口，返回结构化结果（或文本兜底）

### 7. API 设计（/api/v1）

- **项目** `/projects`
  - POST 创建：

```json
{
  "name": "demo",
  "description": "desc",
  "workspace_root": "F:/Codebox/workspace",
  "status": "active"
}
```

- GET 列表：返回 `ProjectOut[]`

- **功能** `/projects/{pid}/features`

  - POST 创建 `FeatureCreate`
  - PATCH 更新 `FeatureUpdate`（含布局/锁定）
  - GET 列表 `FeatureOut[]`
  - PUT 详情 `/projects/{pid}/features/{fid}/details`，写 `files_json`/`file_deps_json`/`llm_notes_json`

- **依赖边** `/projects/{pid}/edges`

  - POST 创建 `EdgeCreate`
  - GET 列表 `EdgeOut[]`

- **文件** `/projects/{pid}/files`

  - GET 列表（懒加载 & 层级刷新）：
    - `parent=<path|null>`（根层为空）
    - `only_dirs=true|false`（默认 false）
    - `limit`/`offset`（默认 200/0）
    - `refresh=true|false`（默认 true；仅刷新当前层级）
  - POST `/scan`：全量（递归）扫描（长耗时，通常不在前端调用）
  - POST `/infer-deps`：文件级依赖推断（可选 paths）

- **图谱** `/projects/{pid}/graph`

  - GET 图快照 `GraphSnapshot`
  - POST `/layout/auto`：自动布局并写回
  - PUT `/layout`：批量写入指定 `(q,r)`

- **任务** `/projects/{pid}/tasks`

  - POST 创建 `TaskCreate`
  - GET 列表 `TaskOut[]`

- **会话（桥接 Registry）** `/sessions`

  - GET `/sessions`：已注册
  - GET `/sessions/running`：运行中（返回对象 `exec_id -> info` 或数组，前端需归一化）
  - POST `/sessions/trigger`：`{"project_id", "session_id", "params", "task_id?", "name?"}`
  - GET `/sessions/{exec_id}/status`：执行状态与记录快照
  - GET `/sessions/{exec_id}/events`：SSE（当前为 keep-alive 占位，后续可代理真正的 token 流）
  - POST `/sessions/stop`、`/sessions/cancel`

- **Agent 健康** `/agents/health`
  - 检测 `qwen` 或 `qwen-code` CLI 可用性与版本

### 8. 约束与规范

- `agent.run(...)` 仅出现在 `@pattern` 内，且 `@pattern` 顶层定义，便于追踪与复用
- 所有“写码/改码”调用 `cli="qwen-code"`，其余可用 `no-tools`（直连模型）
- 所有写入使用 `utils.id_gen.generate_id()` 生成主键，保证分布式可用
- `layout_locked=1` 的 Feature 不参与自动布局
- 静态依赖推断仅作启发式，真实工程以 LLM 推断与扫描结果结合

### 9. 启动与调试

1. 安装依赖并确认 MySQL 可访问

```bash
pip install -r requirements.txt
```

2. 设置环境变量并启动

```bash
set API_PREFIX=/api/v1
set WORKSPACE_ROOT=F:\Codebox
set MYSQL_URI=mysql+pymysql://root:***@host:port/codebox
set SCAN_IGNORE_DIRS=.git,.conda,node_modules,.venv,.polycache,.cache,.mypy_cache,.pytest_cache
set SCAN_MAX_DEPTH=12
set SCAN_HASH=false
python -m uvicorn app.main:app --reload
```

3. 健康检查与基础调用

```bash
curl http://127.0.0.1:8000/api/v1/agents/health
curl -X POST http://127.0.0.1:8000/api/v1/projects -H "Content-Type: application/json" -d '{"name":"demo"}'
```

### 10. 示例流程（E2E）

1. 创建项目并浏览文件（懒加载）

```bash
POST /api/v1/projects {"name":"demo","workspace_root":"F:/Codebox/workspace"}
GET  /api/v1/projects/{pid}/files?parent&limit=500&refresh=true
GET  /api/v1/projects/{pid}/files?parent=app&limit=500&refresh=true
```

2. 新增 2 个功能与依赖边

```bash
POST /api/v1/projects/{pid}/features {"name":"登录"}
POST /api/v1/projects/{pid}/features {"name":"用户管理"}
POST /api/v1/projects/{pid}/edges {"from_feature_id":<登录>,"to_feature_id":<用户管理>,"kind":"requires"}
```

3. 自动布局并获取图谱

```bash
POST /api/v1/projects/{pid}/graph/layout/auto
GET  /api/v1/projects/{pid}/graph
```

4. 写入功能文件上下文，触发会话

```bash
PUT /api/v1/projects/{pid}/features/{fid}/details {"files":[{"path":"app/auth.py","role":"impl","rw":"rw"}]}
POST /api/v1/sessions/trigger {"project_id":pid, "session_id":"project_structure_planner", "params":{"requirement":"..."}}
```

### 11. 已知限制与后续优化

- SSE 事件：当前 `/sessions/{exec_id}/events` 为 keep-alive 占位，后续可将 `SessionMonitor.handle_sse_client` 的 token 流桥接为响应体 `yield`
- `session_runs` 状态落库：当前仅预存 running 记录，建议在轮询到完成/失败时写入 `result_json/records_json/ended_at`（`session_bridge_service.update_run_status` 预留）
- 依赖推断：多个语言与更复杂的解析（如别名、tsconfig 路径映射）可后续增强
- 安全域：当前写文件权限不做限制（按需求暂不考虑），后续可引入白名单与路径穿越防护
- 权限：所有接口默认补齐 `data_user_id/data_dept_id`，后续再加鉴权/租户隔离

### 12. 参考与规范

- PolyAgent 文档：`PolyAgent开发文档.md`
- 使用约定：`agent.run` 仅在 `@pattern`，`@pattern` 顶层定义；`@session_def` 自动注册到 Registry；FastAPI 作为唯一网关对外暴露 `/api/v1` 并桥接 Registry。
